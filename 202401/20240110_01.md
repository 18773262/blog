## 为什么PostgreSQL支持基于表空间的在线备份和完全恢复?    
                                      
### 作者                                      
digoal                                      
                                      
### 日期                                      
2024-01-10                               
                                      
### 标签                                      
PostgreSQL , PolarDB , DuckDB , 表空间备份与完全恢复 , Selectivity Tablespace backup and recovery        
                                      
----                                      
                                      
## 背景     
本文内容有别于[《PostgreSQL如何支持可选择性表空间(Selectivity Tablespace)备份和时间点(PITR)恢复?》](../202401/20240107_01.md)    
  
PostgreSQL在恢复模式中, 从哪个位置开始恢复? backup_label文件内容优先级高于控制文件.  
  
执行pg_start_backup后会产生一个backup_label文件, 记录了这个备份集需要从wal的什么位置开始进行恢复.  执行pg_stop_backup后, backup_label这个文件会被删掉.   
```  
START WAL LOCATION: 0/2000060 (file 000000010000000000000002)  
CHECKPOINT LOCATION: 0/2000098  
BACKUP METHOD: pg_start_backup  
BACKUP FROM: primary  
START TIME: 2024-01-10 03:00:20 UTC  
LABEL: a  
START TIMELINE: 1  
```  
  
将backup_label文件放到$PGDATA, 以恢复模式打开PostgreSQL, 将从backup_label标记的wal位置开始恢复. 此时backup_lable的优先级高于控制文件中的`Latest checkpoint location` wal位置优先级.   
  
基于这个原理, 我们可以实现表空间的备份和时间点恢复吗?  先抛结论:    
- 如果没有备份全局数据(`$PGDATA`), 只有backup_label+表空间+WAL归档, 那么只能进行表空间的完全恢复(恢复到集群最新状态).    
- 如果有备份全局数据(`$PGDATA`)+backup_label+表空间+WAL归档, 那么可以对表空间实现时间点恢复(恢复到过去的某个状态), 这个在下面这篇信息中已经做过实验:   
    - [《PostgreSQL如何支持可选择性表空间(Selectivity Tablespace)备份和时间点(PITR)恢复?》](../202401/20240107_01.md)    
  
为什么没有备份全局数据(`$PGDATA`), 只有表空间+WAL归档, 只能进行表空间的完全恢复(恢复到集群最新状态)?  
- 因为数据库的全局数据文件(`$PGDATA`)是最新的, 类似于拿最新的数据文件直接进行redo恢复, 如果不能将所有wal都回放完整, 也就是集群无法到达最新状态, 那么全局数据(`$PGDATA`)有些block可能是“未来”的, 元数据的内容可能会出现“错误”, 所以有较小概率出现问题.    
  
  
思考: 数据库的全局数据文件块是最新的, 类似于拿最新的数据文件直接进行redo恢复, 有没有问题?   
- 想一想: 异步standby激活成为新主库后, 老的主库需要做rewind才能变成新主库的standby.    
- 但是本例的时间线没有变化, 没有分叉. 只要redo文件完整(归档以及未归档的wal文件都在), 理论上不存在问题.   
  
  
## PostgreSQL基于表空间的在线备份和完全恢复 demo  
前置条件:     
- 开启归档  
- 归档正常  
  
在PostgreSQL 14上做个测试, 使用如下docker环境:     
- [《ARM64版, PostgreSQL docker image》](../202308/20230814_02.md)         
- [《AMD64版, PostgreSQL docker image》](../202307/20230710_03.md)         
  
  
备份步骤:   
- 1、select pg_start_backup('bak');  
- 2、copy backup_label from `$PGDATA`  
- 3、copy tbs   
- 4、select pg_stop_backup();  
  
破坏表空间, 删除数据库实例的tbs数据文件;  
  
恢复:   
- 1、停数据库实例  
- 2、将backup_label拷贝到`$PGDATA`  
- 3、使用备份的tbs覆盖原有的tbs目录  
- 4、配置postgresql.conf recovery  
```  
# 注释归档    
#archive_mode = on     
#archive_command = 'test ! -f /tmp/arch/%f && cp %p /tmp/arch/%f'    
    
# 恢复配置    
restore_command = 'cp /tmp/arch/%f %p'    
recovery_target_timeline = 'latest'    
  
# 配置 zero_damaged_pages 跳过错误的块      
zero_damaged_pages = on   
```  
- 5、touch recovery file  
```    
touch $PGDATA/recovery.signal    
```   
- 6、启动数据库, 恢复到最新状态.    
  
  
## 参考  
src/backend/access/transam/xlog.c    
  
```  
/*  
 * read_backup_label: check to see if a backup_label file is present  
 *  
 * If we see a backup_label during recovery, we assume that we are recovering  
 * from a backup dump file, and we therefore roll forward from the checkpoint  
 * identified by the label file, NOT what pg_control says.  This avoids the  
 * problem that pg_control might have been archived one or more checkpoints  
 * later than the start of the dump, and so if we rely on it as the start  
 * point, we will fail to restore a consistent database state.  
 *  
 * Returns true if a backup_label was found (and fills the checkpoint  
 * location and its REDO location into *checkPointLoc and RedoStartLSN,  
 * respectively); returns false if not. If this backup_label came from a  
 * streamed backup, *backupEndRequired is set to true. If this backup_label  
 * was created during recovery, *backupFromStandby is set to true.  
 */  
static bool  
read_backup_label(XLogRecPtr *checkPointLoc, bool *backupEndRequired,  
                                  bool *backupFromStandby)  
{  
... ...   
```  
  
  
  
- [《PostgreSQL如何支持可选择性表空间(Selectivity Tablespace)备份和时间点(PITR)恢复?》](../202401/20240107_01.md)    
- [《PostgreSQL Selectivity Tablespace PITR - 部分表空间恢复》](../201204/20120426_01.md)      
- [《PostgreSQL recovery target introduce》](../201301/20130130_01.md)  详细介绍了PITR恢复参数的概念.   
    
  
