## PostgreSQL 17 preview - Reduce rate of walwriter wakeups due to async commits   
                      
### 作者                      
digoal                      
                      
### 日期                      
2023-11-28      
                      
### 标签                      
PostgreSQL , PolarDB , walwriter , async commit , wakeup  
                      
----                      
                      
## 背景    
https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=1f395354d8742d57c166104874114b6e0d01e104

```
Reduce rate of walwriter wakeups due to async commits.

author  Heikki Linnakangas <heikki.linnakangas@iki.fi>  
Mon, 27 Nov 2023 15:42:39 +0000 (17:42 +0200)
committer Heikki Linnakangas <heikki.linnakangas@iki.fi>  
Mon, 27 Nov 2023 15:42:39 +0000 (17:42 +0200)
commit  1f395354d8742d57c166104874114b6e0d01e104
tree  6a607b78be1c7e7b6dc812f1dba2a355110eef6a  tree
parent  360392fa2a9bb74338b4864790d18eadb13fd8a8  commit | diff
Reduce rate of walwriter wakeups due to async commits.

XLogSetAsyncXactLSN(), called at asynchronous commit, would wake up
walwriter every time the LSN advances, but walwriter doesn't actually
do anything unless it has at least 'wal_writer_flush_after' full
blocks of WAL to write. Repeatedly waking up walwriter to do nothing
is a waste of CPU cycles in both walwriter and the backends doing the
wakeups. To fix, apply the same logic in XLogSetAsyncXactLSN() to
decide whether to wake up walwriter, as walwriter uses to determine if
it has any work to do.

In the passing, rename misleadingly named 'flushbytes' local variable
to 'flushblocks'.

Author: Andres Freund, Heikki Linnakangas
Discussion: https://www.postgresql.org/message-id/20231024230929.vsc342baqs7kmbte@awork3.anarazel.de
```


```
+   bool        wakeup = false;
+   XLogRecPtr  prevAsyncXactLSN;
 
    SpinLockAcquire(&XLogCtl->info_lck);
    LogwrtResult = XLogCtl->LogwrtResult;
    sleeping = XLogCtl->WalWriterSleeping;
+   prevAsyncXactLSN = XLogCtl->asyncXactLSN;
    if (XLogCtl->asyncXactLSN < asyncXactLSN)
        XLogCtl->asyncXactLSN = asyncXactLSN;
    SpinLockRelease(&XLogCtl->info_lck);
 
    /*
-    * If the WALWriter is sleeping, we should kick it to make it come out of
-    * low-power mode.  Otherwise, determine whether there's a full page of
-    * WAL available to write.
+    * If somebody else already called this function with a more aggressive
+    * LSN, they will have done what we needed (and perhaps more).
     */
-   if (!sleeping)
+   if (asyncXactLSN <= prevAsyncXactLSN)
+       return;
+
+   /*
+    * If the WALWriter is sleeping, kick it to make it come out of low-power
+    * mode, so that this async commit will reach disk within the expected
+    * amount of time.  Otherwise, determine whether it has enough WAL
+    * available to flush, the same way that XLogBackgroundFlush() does.
+    */
+   if (sleeping)
+       wakeup = true;
+   else
    {
-       /* back off to last completed page boundary */
-       WriteRqstPtr -= WriteRqstPtr % XLOG_BLCKSZ;
+       int         flushblocks;
 
-       /* if we have already flushed that far, we're done */
-       if (WriteRqstPtr <= LogwrtResult.Flush)
-           return;
+       flushblocks =
+           WriteRqstPtr / XLOG_BLCKSZ - LogwrtResult.Flush / XLOG_BLCKSZ;
+
+       if (WalWriterFlushAfter == 0 || flushblocks >= WalWriterFlushAfter)
+           wakeup = true;
```
