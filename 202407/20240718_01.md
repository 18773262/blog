## 低配macbook成功跑AI大模型`LLama3:8b`, 感谢ollama   
                                                                  
### 作者                                      
digoal                                      
                                             
### 日期                                           
2024-07-18                                  
                                          
### 标签                                        
PostgreSQL , PolarDB , DuckDB , AI , macOS , ollama , docker          
                                                                 
----                                          
                                                        
## 背景    
我的macbook算是比较低配了吧? M2芯片, 16G内存, 512G磁盘, 系统版本`13.2.1`. 值得庆幸的是macbook 的内存是cpu gpu共享的, 所以这个配置意味着GPU最多能用到16G(理论值).    
  
另外需要感谢ollama, 在macOS上实在是太好用了, 而且支持加载各种大模型. 通过ollama拉起大模型有点像通过docker image创建容器的感觉, 非常便利, 怪不得现在这个开源项目已经有79k star.  
  
## 例子  
1、下载ollama for macos. 解压后把ollama应用目录移动到mac的application目录中即可.    
  
https://ollama.com/  
  
https://github.com/ollama/ollama  
  
命令行帮助说明  
```  
ollama --help  
Large language model runner  
  
Usage:  
  ollama [flags]  
  ollama [command]  
  
Available Commands:  
  serve       Start ollama  
  create      Create a model from a Modelfile  
  show        Show information for a model  
  run         Run a model  
  pull        Pull a model from a registry  
  push        Push a model to a registry  
  list        List models  
  ps          List running models  
  cp          Copy a model  
  rm          Remove a model  
  help        Help about any command  
  
Flags:  
  -h, --help      help for ollama  
  -v, --version   Show version information  
  
Use "ollama [command] --help" for more information about a command.  
```  
  
2、拉取一个小于内存, 本地能跑的模型.  
  
https://ollama.com/library  
  
  
`llama3:8b` 约4.7G, 可以跑起来  
```  
U-4G77XXWF-1921:~ digoal$ ollama pull llama3:8b  
pulling manifest   
pulling 6a0746a1ec1a... 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▏ 4.7 GB                           
pulling 4fa551d4f938... 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▏  12 KB                           
pulling 8ab4849b038c... 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▏  254 B                           
pulling 577073ffcc6c... 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▏  110 B                           
pulling 3f8eb4da87fa... 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▏  485 B                           
verifying sha256 digest   
writing manifest   
removing any unused layers   
success   
```  
  
3、运行本地模型  
  
```  
U-4G77XXWF-1921:~ digoal$ ollama list  
NAME     	ID          	SIZE  	MODIFIED             
llama3:8b	365c0bd3c000	4.7 GB	About a minute ago  
  
  
U-4G77XXWF-1921:~ digoal$ ollama run llama3:8b  
>>> Send a message (/? for help)  
```  
  
4、考考他, 看看回答速度如何?  
  
```  
>>> 请使用中文回答: 简单介绍一下阿里云PolarDB云原生分布式数据库.  
😊  
  
阿里云PolarDB是一款云原生分布式数据库，于2019年推出。它是阿里巴巴集团自主研发的cloud-native分布式关系数据库，可以支持大规模数据存储和处理。PolarDB具备以下特点：  
  
1. **Cloud-Native**：PolarDB 是一款云原生产品，完全基于云计算架构，无需用户维护底层硬件。  
2. **Distributed Architecture**：PolarDB 使用分布式架构，可以根据实际需求动态扩展和调整存储和计算资源。  
3. **Relational Database**：PolarDB 是关系数据库，支持标准SQL语言，可以与其他数据库集成。  
4. **High Availability and Durability**：PolarDB 具有高可用性和数据持久性，可以在出现故障时自动切换到备用节点，以确保业务连续性。  
5. **Scalable Performance**：PolarDB 具有可扩展的性能，可以根据实际需求动态调整计算资源，提高应用程序性能。  
  
使用PolarDB可以解决以下问题：  
  
1. 数据存储和处理需求不断增长的问题。  
2. 分布式系统架构设计和实现问题。  
3. 业务数据安全和高可用性问题。  
  
总的来说，PolarDB 是一款功能强大且灵活的云原生分布式数据库，可以满足复杂应用程序的存储和处理需求。  
```  
  
请使用中文回答(但是SQL text不要使用中文), 输出为markdown格式: 请编写一个postgresql例子, 反映btree,hash,brin,bloom,gist,spgist各个索引接口的差异. 再加一些查询和explain反映使用到这些索引的例子, 最后做个总结, 什么时候使用什么索引.  
  
# PostgreSQL 索引示例  
### 使用 BTREE 索引  
```sql  
CREATE TABLE employees (  
    id INT PRIMARY KEY,  
    name VARCHAR(50),  
    age INT  
);  
  
CREATE INDEX idx_name ON employees USING BTREE (name);  
```  
BTREE 索引是最常用的索引类型，用于处理EQ、NEQ、LT、LE、GT、GE、IN、NOT IN 等查询。  
  
### 查询示例  
```sql  
SELECT * FROM employees WHERE name = 'John';  
```  
Explain:  
```sql  
EXPLAIN SELECT * FROM employees WHERE name = 'John';  
```  
结果：  
```  
"Index Scan using idx_name on employees  (cost=0.29..8.28 rows=1 width=64) (actual time=0.021..0.021 rows=1 loops=1)"  
```  
可以看到，PostgreSQL 使用 BTREE 索引来查找 name='John' 的记录。  
  
### 使用 HASH 索引  
```sql  
CREATE TABLE orders (  
    id INT PRIMARY KEY,  
    customer_id INT NOT NULL,  
    total DECIMAL(10, 2)  
);  
  
CREATE INDEX idx_customer_id ON orders USING HASH (customer_id);  
```  
HASH 索引用于快速查找单个值，通常用于 IN、NOT IN 等查询。  
  
### 查询示例  
```sql  
SELECT * FROM orders WHERE customer_id = 123;  
```  
Explain:  
```sql  
EXPLAIN SELECT * FROM orders WHERE customer_id = 123;  
```  
结果：  
```  
"Index Only Scan using idx_customer_id on orders  (cost=0.29..8.28 rows=1 width=64) (actual time=0.021..0.021 rows=1 loops=1)"  
```  
可以看到，PostgreSQL 使用 HASH 索引来快速查找 customer_id=123 的记录。  
  
### 使用 BRIN 索引  
```sql  
CREATE TABLE sensor_data (  
    id INT PRIMARY KEY,  
    timestamp TIMESTAMP NOT NULL,  
    value DECIMAL(10, 2)  
);  
  
CREATE INDEX idx_timestamp ON sensor_data USING BRIN (timestamp);  
```  
BRIN 索引用于快速查找范围查询，通常用于时间戳或日期范围查询。  
  
### 查询示例  
```sql  
SELECT * FROM sensor_data WHERE timestamp BETWEEN '2020-01-01' AND '2020-12-31';  
```  
Explain:  
```sql  
EXPLAIN SELECT * FROM sensor_data WHERE timestamp BETWEEN '2020-01-01' AND '2020-12-31';  
```  
结果：  
```  
"BRIN Scan using idx_timestamp on sensor_data  (cost=0.29..8.28 rows=100 width=64) (actual time=0.021..0.021 rows=100 loops=1)"  
```  
可以看到，PostgreSQL 使用 BRIN 索引来快速查找 timestamp 在指定范围内的记录。  
  
### 使用 BLOOM 索引  
```sql  
CREATE TABLE products (  
    id INT PRIMARY KEY,  
    category VARCHAR(50),  
    price DECIMAL(10, 2)  
);  
  
CREATE INDEX idx_category ON products USING BLOOM (category);  
```  
BLOOM 索引用于快速查找多个值，通常用于LIKE、IN、NOT IN 等查询。  
  
### 查询示例  
```sql  
SELECT * FROM products WHERE category LIKE '%electronics%';  
```  
Explain:  
```sql  
EXPLAIN SELECT * FROM products WHERE category LIKE '%electronics%';  
```  
结果：  
```  
"Bloom Scan using idx_category on products  (cost=0.29..8.28 rows=100 width=64) (actual time=0.021..0.021 rows=100 loops=1)"  
```  
可以看到，PostgreSQL 使用 BLOOM 索引来快速查找 category 中包含 'electronics' 的记录。  
  
### 使用 GIST 索引  
```sql  
CREATE TABLE shapes (  
    id INT PRIMARY KEY,  
    shape geometry NOT NULL  
);  
  
CREATE INDEX idx_shape ON shapes USING GIST (shape, gist_index);  
```  
GIST 索引用于处理空间数据，通常用于 GIS 应用程序。  
  
### 查询示例  
```sql  
SELECT * FROM shapes WHERE ST_DWithin(shape, 'POINT(1 2)', 10);  
```  
Explain:  
```sql  
EXPLAIN SELECT * FROM shapes WHERE ST_DWithin(shape, 'POINT(1 2)', 10);  
```  
结果：  
```  
"GIST Scan using idx_shape on shapes  (cost=0.29..8.28 rows=100 width=64) (actual time=0.021..0.021 rows=100 loops=1)"  
```  
可以看到，PostgreSQL 使用 GIST 索引来快速查找 shape 中包含指定点的记录。  
  
### 使用 SPGIST 索引  
```sql  
CREATE TABLE paths (  
    id INT PRIMARY KEY,  
    path geometry NOT NULL  
);  
  
CREATE INDEX idx_path ON paths USING SPGIST (path, spgist_index);  
```  
SPGIST 索引用于处理空间路径数据，通常用于 GIS 应用程序。  
  
### 查询示例  
```sql  
SELECT * FROM paths WHERE ST_DWithin(path, 'LINESTRING(0 0, 1 1)', 10);  
```  
Explain:  
```sql  
EXPLAIN SELECT * FROM paths WHERE ST_DWithin(path, 'LINESTRING(0 0, 1 1)', 10);  
```  
结果：  
```  
"SPGIST Scan using idx_path on paths  (cost=0.29..8.28 rows=100 width=64) (actual time=0.021..0.021 rows=100 loops=1)"  
```  
可以看到，PostgreSQL 使用 SPGIST 索引来快速查找 path 中包含指定路径的记录。  
  
总结：  
  
* BTREE 索引用于等值查询和范围查询  
* HASH 索引用于 IN 和 NOT IN 查询  
* BRIN 索引用于范围查询  
* BLOOM 索引用于多个值查询  
* GIST 索引用于空间数据查询  
* SPGIST 索引用于空间路径数据查询  
  
选择合适的索引类型，能够提高数据库性能和查询效率。  
```  
  
```  
>>> 我发现了一些错误, 你觉得哪里错了?  
I'm glad you're eager to help me improve the accuracy of my responses! 🤔  
  
Please go ahead and point out what you think are the errors. I'll do my best to verify them and make any necessary corrections.  
  
Is it something specific in the SQL examples, the Explain plans, or perhaps the text summarizing each index type? Let me know! 💬  
```  
  
```  
>>> bloom 索引是多列等值组合查询, 你用的例子不对  
I apologize for the mistake. You are correct that BLOOM indexes are typically used for multi-column equality combinations, not single-column or range queries.  
  
In other words, a BLOOM index is created by combining multiple columns into a single hash value, allowing for fast lookups on those combined columns. This makes it well-suited for queries that   
filter on multiple columns simultaneously.  
  
Thank you for pointing out the error in my previous example! I'll make sure to provide more accurate information about BLOOM indexes going forward.  
```  
  

`>>> 请使用中文回答: bloom的例子重新来一个`  

  
下面是一个新的 BLOOM 索引示例：  
  
创建一个名为 `orders` 的表，包含客户ID、订单日期和总金额三个字段：  
```sql  
CREATE TABLE orders (  
    customer_id INT NOT NULL,  
    order_date DATE NOT NULL,  
    total DECIMAL(10, 2) NOT NULL  
);  
```  
然后，我们创建一个 BLOOM 索引，组合 `customer_id` 和 `order_date` 两个字段：  
```sql  
CREATE INDEX idx_customer_order ON orders USING BLOOM (customer_id, order_date);  
```  
现在，如果我们想要查找某个客户的所有订单，并且这些订单是在某一天之前或某一天之内，我们可以使用以下查询：  
```sql  
SELECT * FROM orders  
WHERE customer_id = 123 AND order_date BETWEEN '2020-01-01' AND '2021-12-31';  
```  
Explain 的结果：  
```  
"Bloom Scan using idx_customer_order on orders  (cost=0.29..8.28 rows=100 width=64) (actual time=0.021..0.021 rows=100 loops=1)"  
```  
可以看到，PostgreSQL 使用 BLOOM 索引来快速查找符合条件的订单记录。  
  
这个示例演示了 BLOOM 索引如何用于多列等值组合查询。  

  
 
`>>> 还是不对, bloom仅支持等值查询. 请继续修改例子, 用中文回答.`  

  
我错了！BLOOM 索引确实只支持等值查询。  
  
下面是一个新的 BLOOM 索引示例：  
  
创建一个名为 `products` 的表，包含产品名称和分类两个字段：  
```sql  
CREATE TABLE products (  
    name VARCHAR(50) NOT NULL,  
    category VARCHAR(20) NOT NULL  
);  
```  
然后，我们创建一个 BLOOM 索引，组合 `category` 字段：  
```sql  
CREATE INDEX idx_category ON products USING BLOOM (category);  
```  
现在，如果我们想要查找所有电子产品，我们可以使用以下查询：  
```sql  
SELECT * FROM products WHERE category = '电子';  
```  
Explain 的结果：  
```  
"Bloom Scan using idx_category on products  (cost=0.29..8.28 rows=100 width=64) (actual time=0.021..0.021 rows=100 loops=1)"  
```  
可以看到，PostgreSQL 使用 BLOOM 索引来快速查找符合条件的产品记录。  
  
这个示例演示了 BLOOM 索引如何用于等值查询。  
 
  

>>> 没有体现出任意字段等值查询组合, 请继续修改例子, 使用中文回答  

  
我再次错误！BLOOM 索引实际上支持多个等值查询的组合。  
  
下面是一个新的 BLOOM 索引示例：  
  
创建一个名为 `orders` 的表，包含客户ID、订单日期和总金额三个字段：  
```sql  
CREATE TABLE orders (  
    customer_id INT NOT NULL,  
    order_date DATE NOT NULL,  
    total DECIMAL(10, 2) NOT NULL  
);  
```  
然后，我们创建一个 BLOOM 索引，组合 `customer_id` 和 `order_date` 两个字段：  
```sql  
CREATE INDEX idx_customer_order ON orders USING BLOOM (customer_id, order_date);  
```  
现在，如果我们想要查找某个客户的所有订单，并且这些订单是在某一天之前或某一天之内，我们可以使用以下查询：  
```sql  
SELECT * FROM orders WHERE customer_id = 123 AND order_date IN ('2020-01-01', '2020-01-02');  
```  
Explain 的结果：  
```  
"Bloom Scan using idx_customer_order on orders  (cost=0.29..8.28 rows=100 width=64) (actual time=0.021..0.021 rows=100 loops=1)"  
```  
可以看到，PostgreSQL 使用 BLOOM 索引来快速查找符合条件的订单记录。  
  
这个示例演示了 BLOOM 索引如何用于多个等值查询的组合。  

  
## 小结  
1、使用ollama可以非常方便的在M芯片系列的mac上跑AI大模型.     
  
2、速度很快, 一秒20个字左右吧(M2芯片, 16G内存, 512G磁盘).     
  
3、`llama3:8b` 下载4.7G, 实际内存消耗可能小一点, 因为我配置了内存压缩, 可能有一定的作用. 参考:     
- [《禁用 MacOS 的 Swap 分区 - 实测真实有效》](../202212/20221207_01.md)    
  
  
## 参考  
https://ollama.com/  
  
https://cloud.tencent.com/developer/article/2412384  
  
https://www.cybertec-postgresql.com/en/using-ai-to-generate-data-structures/  
  
https://github.com/ollama/ollama  
  
https://github.com/mindsdb/mindsdb  
    
