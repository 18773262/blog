## PolarDB数据库创新设计国赛 - 决赛提交作品指南      
                                                                                        
### 作者                                                            
digoal                                                            
                                                                   
### 日期                                                                 
2024-12-06                                                           
                                                                
### 标签                                                              
PostgreSQL , PolarDB , DuckDB , 国赛 , 决赛提交作品 , 指南      
                                                                                       
----                                                                
                                                                              
## 背景  
看过 [《PolarDB数据库创新设计国赛 - 初赛提交作品指南》](../202410/20241008_04.md) 的同学们一定知道我的风格, 这个指南肯定是保姆级的.     
  
## 太长不看版 (保姆级提交 决赛作品 教程)    
提交方法巨简单, 但是因为决赛比初赛略微复杂, 我已经把决赛要求的SQL都放在了我自己的一个分支里(快献上感谢吧), 你就不用去PDF文件里扣了, 真的是重复且无趣而且容易拷贝错误的操作. 同时我做了一些些的优化(后面会详细说到):    
    
1、下载如下代码并压缩:      
```
git clone -c core.symlinks=true --depth 1 -b polardb-competition-2024 https://gitee.com/digoal/PolarDB-for-PostgreSQL
    
zip -r PolarDB-for-PostgreSQL.zip PolarDB-for-PostgreSQL/ 
```
   
2、将`PolarDB-for-PostgreSQL.zip`代码文件提交到比赛平台     
     
登陆比赛网站: https://tianchi.aliyun.com/competition/entrance/532261/submission/1365     
     
依次点击如下即可提交初赛代码并进行评测:     
- 提交结果 - 镜像路径(配置路径) - TCCFile(上传) PolarDB-for-PostgreSQL.zip - 上传完毕后点击 确定 - 提交     
    
## 正文  
  
1、在你自己的电脑中准备docker desktop调试环境. (你都已经进决赛了, 这个环境相信大家都有了.)   
    
略    
    
2、下载开发镜像, 启动容器, 进入容器    
```    
# 下载开发镜像    
docker pull registry.cn-hangzhou.aliyuncs.com/polardb_pg/polardb_pg_devel:ubuntu20.04      
    
# 启动容器    
docker run -d -it -P --shm-size=1g --cap-add=SYS_PTRACE --cap-add SYS_ADMIN --privileged=true --name polardb_pg_devel registry.cn-hangzhou.aliyuncs.com/polardb_pg/polardb_pg_devel:ubuntu20.04 bash      
    
# 进入容器    
docker exec -ti polardb_pg_devel bash      
```  
  
3、在容器中下载比赛分支代码 (下载我这个分支, 已经吧sql文件都放好了.)    
    
```    
cd /tmp    
    
git clone -c core.symlinks=true --depth 1 -b polardb-competition-2024 https://gitee.com/digoal/PolarDB-for-PostgreSQL  
```  
    
4、在容器中测试以上修改过的代码    
    
生成测试数据若干    
```    
cd /tmp/PolarDB-for-PostgreSQL/tpch-dbgen    
    
make -f makefile.suite    
    
./dbgen -f -s 0.1    
```    
    
将测试数据放到与测试机一致的目录    
```    
cd /tmp/PolarDB-for-PostgreSQL/tpch-dbgen    
sudo mkdir /data    
sudo chown -R postgres:postgres /data    
sudo mv *.tbl /data/    
```    
    
初始化PolarDB数据库集群    
```    
cd /tmp/PolarDB-for-PostgreSQL    
chmod 700 polardb_build.sh       
./polardb_build.sh --without-fbl --debug=off      
```    
    
导入数据、创建索引  
```    
chmod 777 tpch_copy.sh     
    
# 清理已有的数据, 方便你多次测试时使用. 第一次执行清理时因为数据库里还没有表可能会抛出一些错误, 不用管.    
./tpch_copy.sh --clean  
    
# 执行数据导入、创建索引、增加fk等操作   
./tpch_copy.sh     
```   
  
5、决赛就看这22条SQL, 决赛计算这22条SQL的执行耗时, 越快越好.    
  
试试运行22条query, 例如运行第1条sql:     
```  
cd /tmp/PolarDB-for-PostgreSQL/  
time psql -f sql/1.sql  
```  
  
<b>SQL 优化小贴士:</b>       
  
- 根据SQL的执行计划来进行分析, 看SQL的耗时卡点是什么, 针对性的进行优化. 例如查看`sql/1.sql`的执行计划和各个耗时点位:    
```  
echo "explain (analyze,verbose,timing,costs,buffers) `cat sql/1.sql`" | psql -f -   
```  
  
- 可以任意修改`sql/$.sql`文件, 在每一条sql的前面都可以set和unset已设置过的参数, 用以加速当前sql.    
    - 例如使用什么JOIN方法? `hash/merge/nestloop  join`  
    - 设置多大的`work_mem`  
    - 设置多少个并行`parallel`  
    - 是否启用`ePQ`, 以及设置多大的并行  
  
- 采用什么索引方法? `btree/brin/pg_trgm(gin index)`  
- 是否要对数据按某个索引的顺序进行重排? 参看 `cluster` 语法  
- 是否使用其他`table access method`?  
- 是否使用其他计算引擎? `custom scan provider`? 参考: https://github.com/heterodb/pg-strom   
  
6、下面简单介绍一下我这个分支相比竞赛分支修改了哪些内容?  
  
6\.1、 polardb_build.sh  
  
```  
# 使用更大的数据块  
./configure --prefix=$pg_bld_basedir --with-pgport=$pg_bld_port --with-wal-blocksize=32 --with-blocksize=32 $common_configure_flag $configure_flag  
  
# 使用SQL_ASCII编码, 关闭块校验  
su_eval "$pg_bld_basedir/bin/initdb -E SQL_ASCII --locale=C -U $pg_db_user -D $pg_bld_master_dir $tde_initdb_args"  
  
# 一些参数设置  
        # add by digoal BEGIN  
        random_page_cost = 1.1   
        shared_buffers = '8GB'  
        work_mem = '256MB'  
        autovacuum = off  
        checkpoint_timeout = 1d  
        synchronous_commit = off  
        full_page_writes = off  
        maintenance_work_mem = '1GB'  
        polar_bulk_read_size = '128kB'  
        polar_bulk_extend_size = '4MB'  
        polar_index_create_bulk_extend_size = 512  
        parallel_leader_participation = off  
        max_parallel_workers = 6  
        max_parallel_workers_per_gather = 4  
        min_parallel_index_scan_size = 0  
        min_parallel_table_scan_size = 0  
        parallel_setup_cost = 0  
        parallel_tuple_cost = 0  
        # add by digoal END  
```  
  
6\.2、 tpch_copy.sh  
  
```  
# 使用float8 替代了numeric类型 ; 可能导致结果校验错误  
# sed -i "s/DECIMAL(15,2)/float8/g" ./tpch-dbgen/dss.ddl   
  
psql -f $tpch_dir/dss.ddl   
  
# 使用了unlogged table, 并设置几个大表的并行度  
echo "  
update pg_class set relpersistence ='u' where relnamespace='public'::regnamespace;  
alter table lineitem set (parallel_workers = 4);  
alter table orders set (parallel_workers = 3);  
alter table partsupp set (parallel_workers = 3);  
alter table customer set (parallel_workers = 3);  
alter table part set (parallel_workers = 3);" | psql -f -  
  
# 并行导入, 创建PK  
###################### PHASE 2: load data ######################  
# 读取file.txt中的命令，并使用&符号使其在后台执行  
while IFS= read -r cmd; do  
    # 当已经有N个命令在执行时，等待直到其中一个执行完毕  
    # jobs -p -r  
    while (( $(jobs -p -r | wc -l) >= 3 )); do  
        sleep 0.1  
    done  
    {  
  psql -h ~/tmp_master_dir_polardb_pg_1100_bld -c "${cmd}"  
    } &  
done < file.txt  
  
wait  
     
# 增加了几个可能用得上的索引   
# 读取file.txt1中的命令，并使用&符号使其在后台执行  
while IFS= read -r cmd; do  
    # 当已经有N个命令在执行时，等待直到其中一个执行完毕  
    # jobs -p -r  
    while (( $(jobs -p -r | wc -l) >= 3 )); do  
        sleep 0.1  
    done  
    {  
  psql -h ~/tmp_master_dir_polardb_pg_1100_bld -c "${cmd}"  
    } &  
done < file.txt1  
  
wait  
  
# 设置FK约束  
###################### PHASE 3: add primary and foreign key ######################  
# 读取file.txt2中的命令，并使用&符号使其在后台执行  
while IFS= read -r cmd; do  
    # 当已经有8个命令在执行时，等待直到其中一个执行完毕  
    # jobs -p -r  
    while (( $(jobs -p -r | wc -l) >= 8 )); do  
        sleep 0.1  
    done  
    {  
  psql -h ~/tmp_master_dir_polardb_pg_1100_bld -c "${cmd}"  
    } &  
done < file.txt2  
  
wait  
  
# 约束生效、把unlogged table改为logged table, 生成表统计信息和vm文件.    
psql -h ~/tmp_master_dir_polardb_pg_1100_bld -c "update pg_constraint set convalidated=true where convalidated<>true;"  
psql -h ~/tmp_master_dir_polardb_pg_1100_bld -c "update pg_class set relpersistence ='p' where relnamespace='public'::regnamespace;"  
psql -h ~/tmp_master_dir_polardb_pg_1100_bld -c "vacuum analyze;"  
```  
  
6\.3、 新增sql目录  
  
`sql/1~22.sql`  
  
6\.4、 新增3个文件, 分别是导入和建PK、建索引、加FK约束的SQL.    
```  
file.txt  
file.txt1  
file.txt2  
```  
  
7、在容器中压缩代码分支    
    
先停库    
```    
pg_ctl stop -m fast -D ~/tmp_master_dir_polardb_pg_1100_bld    
```    
    
清理编译过程产生的内容    
```    
cd /tmp/PolarDB-for-PostgreSQL/tpch-dbgen    
make clean -f makefile.suite    
    
cd /tmp/PolarDB-for-PostgreSQL    
make clean    
make distclean    
```    
    
打包    
```    
sudo apt-get install -y zip    
cd /tmp    
zip -r PolarDB-for-PostgreSQL.zip PolarDB-for-PostgreSQL/    
```    
    
8、在宿主机操作, 将容器中打包好的代码文件拷贝到宿主机    
```    
cd ~/Downloads    
docker cp polardb_pg_devel:/tmp/PolarDB-for-PostgreSQL.zip ./    
```    
    
9、将代码文件提交到比赛平台    
    
打开网站: https://tianchi.aliyun.com/competition/entrance/532261/submission/1365    
    
依次点击    
- 提交结果    
- 镜像路径 - 配置路径 - TCCFile 上传`~/Downloads/PolarDB-for-PostgreSQL.zip` - 确定   
    - 如果之前已经提交了, 要先点击删除再上传     
- 上传完毕后, 点击提交    
    
组委会终于把运行日志开放给同学们了, 在这个提交页面, 你可以刷新查看实时运行的日志, 方便同学们针对慢的SQL进行调试.    
    
10、查看成绩    
    
https://tianchi.aliyun.com/competition/entrance/532261/score    
     
平台查询分数和对应的代码分支好像不太方便, 每次提交出成绩后建议自己保存一下分数以及对应的代码版本. 方便未来基于最优的版本继续迭代.       
      
11、提交代码说明和方案(<b>千万不要忘记这步, 否则即使成绩能进决赛也会被认为放弃决赛资格</b>)      
     
根据初赛评测方案, 将代码说明和方案按标准的 邮件标题 发送到邮箱 `cscc-polardb@hz.cmpbook.com`     
      
[决赛赛题和评测方案](https://gitlab.eduxiji.net/csc1/csc-pb/2024-pb/-/blob/main/%E5%86%B3%E8%B5%9B%E8%B5%9B%E9%A2%98%E5%92%8C%E8%AF%84%E6%B5%8B%E6%96%B9%E6%A1%88.pdf)        
     
## 参考    
- [《开源PolarDB|PostgreSQL 应用开发者&DBA 公开课 - 5.9 PolarDB开源版本必学特性 - 玩转PolarDB 开源社区》](../202401/20240130_04.md)      
- [《开源PolarDB|PostgreSQL 应用开发者&DBA 公开课 - 5.7 PolarDB开源版本必学特性 - PolarDB 应用实践实验》](../202401/20240129_01.md)      
    
https://gitlab.eduxiji.net/csc1/csc-pb/2024-pb/-/tree/main    
    
https://tianchi.aliyun.com/specials/promotion/2024-csdcc-polardb    
    
https://tianchi.aliyun.com/competition/entrance/532261/submission/1365    
     
### PS  
更多优化方法请参考如下文章, 注意并不是所有的优化tips都是大赛允许的, 所以还请自行甄别:    
- [《PolarDB for PostgreSQL TPCH 测试与优化tips》](../202406/20240619_01.md)    
- [《PostgreSQL PoC测试优化 tips》](../202406/20240618_01.md)    
- [《性能爽翻了, 在PolarDB plpython中使用DuckDB》](../202411/20241125_02.md)    
- [《PostgreSQL 向量化执行插件(瓦片式实现-vops) 10x提速OLAP》](../201702/20170225_01.md)    
- [《PolarDB 开源版通过 duckdb_fdw 支持 parquet 列存数据文件以及高效OLAP / TPCH》](../202212/20221209_02.md)    
- [《开源PolarDB|PostgreSQL 应用开发者&DBA 公开课 - 5.7 PolarDB开源版本必学特性 - PolarDB 应用实践实验》](../202401/20240129_01.md)    
- [《PostgreSQL 并行计算tpc-h测试和优化分析》](../201611/20161108_01.md)    
  
  
  
#### [期望 PostgreSQL|开源PolarDB 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB 开源数据库](https://openpolardb.com/home "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
